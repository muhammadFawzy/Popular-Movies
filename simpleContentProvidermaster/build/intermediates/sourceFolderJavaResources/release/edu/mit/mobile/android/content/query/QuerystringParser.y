/*
 * A parser to translate from querystring parameters to SQL queries.
 *
 * Copyright (C) 2012-2013 MIT Mobile Experience Lab
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation version
 * 2.1 of the License.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

%language "Java"
%name-prefix "QuerystringParser"
%define package edu.mit.mobile.android.content.query
%define parser_class_name "QuerystringParser"
%define public
/* all tokens will be used as strings. */
%define stype "String"
%define throws SQLGenerationException

/* this lets us avoid needing to instantiate the lexer in application code */
%lex-param {String query}

/* this parameter lets an input key be aliased to another (possibly qualified) column name */
%parse-param {HashMap<String, String> columnAliases}


%code imports {

import java.io.IOException;
import java.io.StreamTokenizer;
import java.io.StringReader;
import java.io.UnsupportedEncodingException;
import java.lang.StringBuilder;
import java.net.URLDecoder;
import java.util.HashMap;
import java.util.LinkedList;

import edu.mit.mobile.android.content.AndroidVersions;
import edu.mit.mobile.android.content.SQLGenUtils;
import edu.mit.mobile.android.content.SQLGenerationException;

}

%code {

	private StringBuilder mSb = new StringBuilder();
	private LinkedList<String> mSelectionArgs = new LinkedList<String>();

    private final HashMap<String, String> mColumnAlias = new HashMap<String, String>();


/**
 * Returns the resulting SQL query string generated by {@link #parse()}. Any
 * arguments passed in will be replaced with placeholders and can be retrieved
 * by {@link #getSelectionArgs()}.
 */
public String getResult(){
    return mSb.toString();
}

/**
 * Returns the selection arguments that were discovered by {@link #parse()}.
 */
public String[] getSelectionArgs(){
	return mSelectionArgs.toArray(new String[mSelectionArgs.size()]);
}

/**
 * Indicates that the parser has encountered an error while parsing the query.
 */
public static class ParseException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    public ParseException(String msg){
        super(msg);
    }
}


    private void appendColumnName(String key) {
    if (!SQLGenUtils.isValidName(key)) {
        throw new SQLGenerationException("illegal column name in query: '" + key
                                                + "'");
    }
        if (columnAliases != null && columnAliases.containsKey(key)) {
            mSb.append(SQLGenUtils.escapeQualifiedColumn(columnAliases.get(key)));
        } else {
            mSb.append('"');
            mSb.append(key);
            mSb.append('"');
        }
	}
}

%code lexer {
        private final StreamTokenizer mTokenizer;
        private String mLVal;

        public YYLexer(String str) {
            mTokenizer = new StreamTokenizer(new StringReader(str));
            mTokenizer.resetSyntax();
            mTokenizer.eolIsSignificant(false);
            mTokenizer.lowerCaseMode(false);

            // standard words, no symbols.
            mTokenizer.wordChars('A', 'Z');
            mTokenizer.wordChars('a', 'z');
            mTokenizer.wordChars('a', 'z');
            mTokenizer.wordChars('0', '9');
            mTokenizer.wordChars('%', '%');
            mTokenizer.wordChars('.', '.');
            mTokenizer.wordChars('-', '-');
            mTokenizer.wordChars('*', '*');
            mTokenizer.wordChars('_', '_');
            mTokenizer.wordChars('+', '+');
            mTokenizer.wordChars('\u00A0', '\u00FF');
        }

        @Override
        public String getLVal() {
            return mLVal;
        }

        @Override
        public int yylex() throws IOException {
            final int ttype = mTokenizer.nextToken();
            switch (ttype){
                case StreamTokenizer.TT_WORD:
                    mLVal = mTokenizer.sval;
                    return QuerystringParser.STR;

                case StreamTokenizer.TT_EOF:
                    return QuerystringParser.EOF;

                default:
                    return mTokenizer.ttype;
            }
        }

        @Override
        public void yyerror(String s) throws ParseException {
            throw new ParseException(s + " near '" + mLVal + "'");
        }
}

/* grammar declaration */

%token <String> STR "string"
%type <String> key
%type <String> value

%%
query: /* empty */
     | params

params: param
      | params join param
      | params join open_paren params close_paren
      | open_paren params close_paren

open_paren: '(' { mSb.append('('); }
close_paren: ')' { mSb.append(')'); }

join: '&' { mSb.append(" AND "); }
    | '|' { mSb.append(" OR "); }


param: key comparison value
     | key not like likevalue

comparison: equals
          | not_equals
          | gt
          | gte
		  | lt
		  | lte

not_equals: '!' '=' { mSb.append(AndroidVersions.SQLITE_SUPPORTS_IS_ISNOT ? " IS NOT ?" : " != ?"); }

equals: '=' { mSb.append(AndroidVersions.SQLITE_SUPPORTS_IS_ISNOT ? " IS ?" : " = ?"); }

gt:  '>'     { mSb.append(" > ?"); }
gte: '>' '=' { mSb.append(" >= ?"); }
lt:  '<'     { mSb.append(" < ?"); }
lte: '<' '=' { mSb.append(" <= ?"); }

like: '~' '=' { mSb.append(" LIKE ?"); }

not: /* empty */
   | '!' { mSb.append(" NOT"); }

key: STR { appendColumnName($1); }

value: STR {
    try {
        mSelectionArgs.add(URLDecoder.decode($1, "utf-8"));
     }catch(UnsupportedEncodingException e){
         SQLGenerationException sqle = new SQLGenerationException();
         sqle.initCause(e);
         throw sqle;
     }
}
/* LIKE values are prefixed/suffixed with the SQL '%' wildcard */
likevalue: STR {
    try {
        mSelectionArgs.add('%' + URLDecoder.decode($1, "utf-8") + '%');
     }catch(UnsupportedEncodingException e){
         SQLGenerationException sqle = new SQLGenerationException();
         sqle.initCause(e);
         throw sqle;
     }
}

%%

